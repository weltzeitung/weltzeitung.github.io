<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Schach gegen KI</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css">
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      margin: 20px;
    }
    #board {
      width: 90vw;
      max-width: 500px;
      margin: 20px auto;
    }
    #controls {
      margin-top: 10px;
    }
    button, select {
      padding: 10px;
      font-size: 16px;
      margin: 5px;
    }
    /* Damit die Overlays korrekt positioniert werden */
    #board .square-55d63 {
      position: relative;
    }
    /* Stil für die legalen Zugmarkierungen (dunkelgraue Kreise) */
    .legal-move {
      width: 20px;
      height: 20px;
      background-color: rgba(0, 0, 0, 0.5);
      border-radius: 50%;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
    }
    /* Optional: Markierung der ausgewählten Figur (Rahmen) */
    .selected-square {
      box-shadow: inset 0 0 0 3px rgba(0, 0, 0, 0.5);
    }
  </style>
</head>
<body>
  <h1>Schach gegen KI</h1>
  <div id="board"></div>
  <div id="controls">
    <select id="difficulty">
      <option value="easy">Leicht</option>
      <option value="medium">Mittel</option>
      <option value="hard">Schwer</option>
    </select>
    <button id="resetBtn">Reset</button>
  </div>

  <!-- jQuery wird benötigt -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
  <!-- chess.js und chessboard.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.12.0/chess.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js"></script>

  <script>
    var board = null;
    var game = new Chess();
    var aiThinking = false;
    var difficultySelect = document.getElementById("difficulty");

    // Globale Variablen für Klick-Zugsteuerung
    var selectedSquare = null;
    var legalMoves = [];

    // Bewertungsfunktion: Materialsumme
    function evaluateBoard(gameInstance) {
      var boardArray = gameInstance.board();
      var totalEvaluation = 0;
      var pieceValues = { p: 100, n: 320, b: 330, r: 500, q: 900, k: 20000 };
      for (var i = 0; i < boardArray.length; i++) {
        for (var j = 0; j < boardArray[i].length; j++) {
          var piece = boardArray[i][j];
          if (piece) {
            var value = pieceValues[piece.type];
            totalEvaluation += (piece.color === 'w' ? value : -value);
          }
        }
      }
      return totalEvaluation;
    }

    // Minimax mit Alpha-Beta-Pruning
    function minimax(gameInstance, depth, alpha, beta, isMaximizingPlayer) {
      if (depth === 0 || gameInstance.game_over()) {
        return [evaluateBoard(gameInstance), null];
      }
      var moves = gameInstance.moves();
      var bestMove = null;
      if (isMaximizingPlayer) {
        var maxEval = -Infinity;
        for (var i = 0; i < moves.length; i++) {
          gameInstance.move(moves[i]);
          var evaluation = minimax(gameInstance, depth - 1, alpha, beta, false)[0];
          gameInstance.undo();
          if (evaluation > maxEval) {
            maxEval = evaluation;
            bestMove = moves[i];
          }
          alpha = Math.max(alpha, evaluation);
          if (beta <= alpha) break;
        }
        return [maxEval, bestMove];
      } else {
        var minEval = Infinity;
        for (var i = 0; i < moves.length; i++) {
          gameInstance.move(moves[i]);
          var evaluation = minimax(gameInstance, depth - 1, alpha, beta, true)[0];
          gameInstance.undo();
          if (evaluation < minEval) {
            minEval = evaluation;
            bestMove = moves[i];
          }
          beta = Math.min(beta, evaluation);
          if (beta <= alpha) break;
        }
        return [minEval, bestMove];
      }
    }

    function getBestMove(gameInstance, depth) {
      return minimax(gameInstance, depth, -Infinity, Infinity, gameInstance.turn() === 'w')[1];
    }

    // KI-Zug: Verringerte Verzögerung (50ms statt 250ms)
    function makeAIMove() {
      if (game.game_over()) return;
      aiThinking = true;
      setTimeout(function() {
        var difficulty = difficultySelect.value;
        var move;
        if (difficulty === 'easy') {
          var moves = game.moves();
          move = moves[Math.floor(Math.random() * moves.length)];
        } else if (difficulty === 'medium') {
          move = getBestMove(game, 2);
          if (!move) {
            var moves = game.moves();
            move = moves[Math.floor(Math.random() * moves.length)];
          }
        } else if (difficulty === 'hard') {
          move = getBestMove(game, 4);
          if (!move) {
            var moves = game.moves();
            move = moves[Math.floor(Math.random() * moves.length)];
          }
        }
        game.move(move);
        board.position(game.fen());
        // Nach jedem Zug die draggable-Option (distance) aktualisieren
        updateDraggableOptions();
        aiThinking = false;
      }, 50);
    }

    // Funktionen zum Markieren und Entfernen der Zugpunkte
    function highlightSquares(squares) {
      removeHighlights();
      squares.forEach(function(sq) {
        var squareEl = $('#board .square-55d63[data-square="' + sq + '"]');
        if (squareEl.length > 0) {
          squareEl.append('<div class="legal-move"></div>');
        }
      });
    }
    function removeHighlights() {
      $('#board .legal-move').remove();
      $('#board .square-55d63').removeClass('selected-square');
    }

    // Aktualisiert die jQuery UI draggable-Option, sodass ein kleiner Mausbewegungsabstand
    // notwendig ist, bevor ein Drag gestartet wird. So werden Klicks besser erkannt.
    function updateDraggableOptions() {
      // Setze "distance" auf 10 Pixel für alle Figuren
      $('#board .piece').draggable("option", "distance", 10);
    }

    // Konfiguration des Schachbretts (Drag & Drop bleibt erhalten)
    var config = {
      draggable: true,
      position: 'start',
      // Angepasster Pfad zu den Figuren (z. B. in "chesspieces/")
      pieceTheme: 'chesspieces/{piece}.png',
      onDragStart: function(source, piece) {
        // Verhindere Züge, wenn KI denkt, Spiel vorbei oder falsche Figur ausgewählt
        if (aiThinking || game.game_over() ||
            (game.turn() === 'w' && piece.indexOf('b') === 0) ||
            (game.turn() === 'b' && piece.indexOf('w') === 0)) {
          return false;
        }
      },
      onDrop: function(source, target) {
        var move = game.move({
          from: source,
          to: target,
          promotion: 'q'
        });
        if (move === null) return 'snapback';
        board.position(game.fen());
        // Aktualisiere draggable-Option, da sich die Figuren neu positionieren
        updateDraggableOptions();
        // Starte den KI-Zug mit verkürzter Verzögerung
        setTimeout(makeAIMove, 50);
      },
      onSnapEnd: function() {
        board.position(game.fen());
        updateDraggableOptions();
      }
    };

    board = Chessboard('board', config);
    updateDraggableOptions();

    // Klick-Event für die Felder (unterstützt Auswahl und Ausführung eines Zugs)
    $('#board').on('click', '.square-55d63', function() {
      if (aiThinking || game.game_over()) return;
      var square = $(this).attr('data-square');
      var clickedPiece = game.get(square);

      // Falls noch keine Auswahl getroffen wurde und eine eigene Figur vorhanden ist…
      if (!selectedSquare) {
        if (clickedPiece && clickedPiece.color === game.turn()) {
          selectedSquare = square;
          legalMoves = game.moves({ square: square, verbose: true }).map(function(move) { return move.to; });
          $(this).addClass('selected-square');
          highlightSquares(legalMoves);
        }
      } else {
        // Auswahl aufheben, wenn auf dasselbe Feld geklickt wird
        if (square === selectedSquare) {
          selectedSquare = null;
          legalMoves = [];
          removeHighlights();
          return;
        }
        // Wechsel der Auswahl, wenn eine andere eigene Figur geklickt wird
        if (clickedPiece && clickedPiece.color === game.turn()) {
          selectedSquare = square;
          legalMoves = game.moves({ square: square, verbose: true }).map(function(move) { return move.to; });
          removeHighlights();
          $(this).addClass('selected-square');
          highlightSquares(legalMoves);
          return;
        }
        // Wurde ein legal markiertes Zielfeld angeklickt, führe den Zug aus.
        if (legalMoves.indexOf(square) !== -1) {
          var move = game.move({
            from: selectedSquare,
            to: square,
            promotion: 'q'
          });
          if (move !== null) {
            board.position(game.fen());
            updateDraggableOptions();
            setTimeout(makeAIMove, 50);
          }
        }
        selectedSquare = null;
        legalMoves = [];
        removeHighlights();
      }
    });

    // Reset-Knopf: Setzt Spiel und Brett zurück
    document.getElementById("resetBtn").addEventListener("click", function() {
      game.reset();
      board.start();
      selectedSquare = null;
      legalMoves = [];
      removeHighlights();
      updateDraggableOptions();
    });
  </script>
</body>
</html>
